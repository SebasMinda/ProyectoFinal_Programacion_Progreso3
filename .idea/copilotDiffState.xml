<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/clases/Utilidades.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/clases/Utilidades.java" />
              <option name="originalContent" value="package clases;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.Statement;&#10;import java.sql.Timestamp;&#10;&#10;/**&#10; * Clase Utilidades: concentra funciones &quot;de apoyo&quot; para trabajar con la BD.&#10; *&#10; * Explicación simple (pero clara):&#10; * - Abre la conexión a MySQL.&#10; * - Inserta y consulta datos de: clientes, viajes y ventas.&#10; * - Permite reiniciar tablas (borrar todo y reiniciar IDs).&#10; * - Controla disponibilidad de asientos por clase.&#10; * - Realiza la reserva con transacción para no dejar datos incompletos.&#10; */&#10;public class Utilidades {&#10;&#10;    /**&#10;     * Crea y devuelve una conexión a MySQL usando datos fijos (hardcodeados).&#10;     * - Si la conexión falla (credenciales, BD apagada, etc.) imprime error y retorna null.&#10;     */&#10;    public Connection getConnection() {&#10;        String url = &quot;jdbc:mysql://localhost:3306/cliente&quot;;&#10;        String user = &quot;root&quot;;&#10;        String passwd = &quot;sasa&quot;;&#10;&#10;        try {&#10;            // DriverManager se encarga de abrir la conexión con la URL + credenciales&#10;            return DriverManager.getConnection(url, user, passwd);&#10;        } catch (Exception ex) {&#10;            // Para depurar rápido: muestra el motivo del fallo en consola&#10;            ex.printStackTrace();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // =========================&#10;    //         CLIENTES&#10;    // =========================&#10;&#10;    /**&#10;     * Inserta un cliente en la tabla `cliente`.&#10;     *&#10;     * Qué hace paso a paso:&#10;     * - Guarda nombre, apellido, correo e identificación.&#10;     * - Calcula el total de asientos comprados si no viene definido.&#10;     * - Guarda cuántos asientos fueron económicos y cuántos premium.&#10;     * - Si la inserción fue exitosa, busca el idCliente generado y lo asigna al objeto Cliente.&#10;     *&#10;     * Nota:&#10;     * - No lanza excepciones hacia afuera, solo imprime la traza.&#10;     */&#10;    public void insetarDatos(Cliente cliente, Connection conn) {&#10;        String sql = &quot;INSERT INTO cliente (nombre, apellido, email, identificacion, asientosComprados, asientosClaseEconomica, asientosClasePremium, precio) VALUES (?,?,?,?,?,?,?,?)&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            // 1) Guardamos los datos básicos del cliente en el INSERT&#10;            ps.setString(1, cliente.getNombre());&#10;            ps.setString(2, cliente.getApellido());&#10;            ps.setString(3, cliente.getEmail());&#10;            ps.setString(4, cliente.getIdentificacion());&#10;&#10;            // 2) Total de asientos: si está en 0, lo calculamos sumando eco + premium&#10;            int totalAsientos = cliente.getAsientosComprados();&#10;            if (totalAsientos &lt;= 0) {&#10;                totalAsientos = cliente.getAsientosClaseEconomica() + cliente.getAsientosClasePremium();&#10;            }&#10;&#10;            // 3) Guardamos los asientos y el precio en la tabla&#10;            ps.setInt(5, totalAsientos);&#10;            ps.setInt(6, cliente.getAsientosClaseEconomica());&#10;            ps.setInt(7, cliente.getAsientosClasePremium());&#10;            ps.setDouble(8, cliente.getPrecio());&#10;&#10;            // 4) Ejecuta el INSERT y devuelve cuántas filas se insertaron&#10;            int resultado = ps.executeUpdate();&#10;&#10;            if (resultado &gt; 0) {&#10;                System.out.println(&quot;Venta Registrada&quot;);&#10;&#10;                // 5) Recuperar el ID para que las ventas queden asociadas al cliente correcto&#10;                //    (se busca por identificacion y se toma el último id insertado con esa identificacion)&#10;                try (PreparedStatement psId = conn.prepareStatement(&#10;                        &quot;SELECT idCliente FROM cliente WHERE identificacion = ? ORDER BY idCliente DESC LIMIT 1&quot;)) {&#10;&#10;                    psId.setString(1, cliente.getIdentificacion());&#10;&#10;                    try (ResultSet rs = psId.executeQuery()) {&#10;                        if (rs.next()) {&#10;                            // Guardamos el id generado dentro del objeto cliente en memoria&#10;                            cliente.setIdCliente(rs.getInt(&quot;idCliente&quot;));&#10;                        }&#10;                    }&#10;&#10;                } catch (Exception exId) {&#10;                    // Si falla solo esta parte, el cliente pudo insertarse igual&#10;                    exId.printStackTrace();&#10;                }&#10;&#10;            } else {&#10;                System.out.println(&quot;El Cliente no se insertó.&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resetea la tabla `cliente`:&#10;     * - Desactiva temporalmente FOREIGN_KEY_CHECKS para evitar error por llaves foráneas.&#10;     * - TRUNCATE borra todo y reinicia el AUTO_INCREMENT (IDs desde 1).&#10;     * - Luego vuelve a activar FOREIGN_KEY_CHECKS.&#10;     */&#10;    public void resetearClientes(Connection conn) {&#10;        try (Statement stmt = conn.createStatement()) {&#10;&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 0&quot;);&#10;            stmt.executeUpdate(&quot;TRUNCATE TABLE cliente&quot;);&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 1&quot;);&#10;&#10;            System.out.println(&quot;Tabla de clientes reseteada (ID reiniciado).&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resetea la tabla `viajes`:&#10;     * - Borra todos los viajes y reinicia el contador de IDs.&#10;     */&#10;    public void resetearviajes(Connection conn) {&#10;        try (Statement stmt = conn.createStatement()) {&#10;&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 0&quot;);&#10;            stmt.executeUpdate(&quot;TRUNCATE TABLE viajes&quot;);&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 1&quot;);&#10;&#10;            System.out.println(&quot;Tabla de viajes reseteada (ID reiniciado).&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resetea la tabla `ventas`:&#10;     * - Borra todas las ventas y reinicia el contador de IDs.&#10;     */&#10;    public void resetearventas(Connection conn) {&#10;        try (Statement stmt = conn.createStatement()) {&#10;&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 0&quot;);&#10;            stmt.executeUpdate(&quot;TRUNCATE TABLE ventas&quot;);&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 1&quot;);&#10;&#10;            System.out.println(&quot;Tabla de clientes ventas (ID reiniciado).&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //      LISTAR CLIENTES&#10;    // =========================&#10;&#10;    /**&#10;     * Muestra por consola los clientes registrados.&#10;     * - Consulta campos básicos y los imprime creando un objeto Cliente por cada fila.&#10;     */&#10;    public void obtenerDatos(Connection conn) {&#10;        String sql = &quot;SELECT idCliente, nombre, apellido, email, identificacion, asientosComprados, asientosClaseEconomica, asientosClasePremium, precio FROM cliente&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            while (rs.next()) {&#10;                // Creamos el objeto Cliente con los datos de la fila actual&#10;                Cliente cli = new Cliente(&#10;                        rs.getInt(&quot;idCliente&quot;),&#10;                        rs.getString(&quot;nombre&quot;),&#10;                        rs.getString(&quot;apellido&quot;),&#10;                        rs.getString(&quot;email&quot;),&#10;                        rs.getString(&quot;identificacion&quot;),&#10;                        rs.getInt(&quot;asientosComprados&quot;),&#10;                        rs.getInt(&quot;asientosClaseEconomica&quot;),&#10;                        rs.getInt(&quot;asientosClasePremium&quot;),&#10;                        rs.getDouble(&quot;precio&quot;));&#10;                System.out.println(cli+&quot;\n&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //          VIAJES&#10;    // =========================&#10;&#10;    /**&#10;     * Inserta un viaje en la tabla `viajes`.&#10;     *&#10;     * Detalles:&#10;     * - Guarda origen/destino, cupos totales, cupos por clase y precios.&#10;     * - Inicializa asientosvendidos en 0 porque el viaje inicia sin ventas.&#10;     * - Guarda ganancias iniciales (normalmente 0).&#10;     */&#10;    public void insetarDatosViaje(Viajes viaje, Connection conn) {&#10;        String sql = &quot;INSERT INTO viajes (origen, destino, cantidadTotal, asientosClasePremium, asientosClaseEconomica, precioEconomica, precioPremium, asientosVendidos,ganancias) VALUES (?,?,?,?,?,?,?,?,?)&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            ps.setString(1, viaje.getOrigen());&#10;            ps.setString(2, viaje.getDestino());&#10;            ps.setInt(3, viaje.getCantidadTotal());&#10;&#10;            // Cupos por clase&#10;            ps.setInt(4, viaje.getAsientosClasePremium());&#10;            ps.setInt(5, viaje.getAsientosClaseEconomica());&#10;&#10;            // Precios por clase&#10;            ps.setDouble(6, viaje.getPrecioEconomica());&#10;            ps.setDouble(7, viaje.getPrecioPremium());&#10;&#10;            // Viaje recién creado =&gt; 0 vendidos&#10;            ps.setInt(8, 0);&#10;&#10;            // Ganancias iniciales (normalmente 0)&#10;            ps.setDouble(9, viaje.getGanancias());&#10;&#10;            int resultado = ps.executeUpdate();&#10;&#10;            if (resultado &gt; 0) System.out.println(&quot;El viaje se ha insertado correctamente..&quot;);&#10;            else System.out.println(&quot;El viaje no se inserto..&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Muestra todos los viajes con ganancias (vista para administrador).&#10;     *&#10;     * Retorna:&#10;     * - 1 si hay viajes.&#10;     * - 0 si no hay viajes o si ocurre error.&#10;     */&#10;    public int obtenerDatosViaje(Connection conn) {&#10;        String sql = &quot;SELECT idViaje, origen, destino, cantidadTotal, asientosClasePremium, asientosClaseEconomica, precioEconomica, precioPremium, asientosVendidos, ganancias FROM viajes&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            int hayVuelos = 0;&#10;&#10;            while (rs.next()) {&#10;                hayVuelos = 1;&#10;&#10;                // Creamos el objeto Viajes con toda la info&#10;                Viajes vjs = new Viajes(&#10;                rs.getInt(&quot;idViaje&quot;),&#10;                rs.getString(&quot;origen&quot;),&#10;                rs.getString(&quot;destino&quot;),&#10;                rs.getInt(&quot;cantidadTotal&quot;),&#10;                rs.getInt(&quot;asientosClasePremium&quot;),&#10;                rs.getInt(&quot;asientosClaseEconomica&quot;),&#10;                rs.getDouble(&quot;precioEconomica&quot;),&#10;                rs.getDouble(&quot;precioPremium&quot;),&#10;                rs.getInt(&quot;asientosVendidos&quot;),&#10;                rs.getDouble(&quot;ganancias&quot;)&#10;                );&#10;&#10;                System.out.println(vjs);&#10;            }&#10;&#10;            // Si no entró al while, no hay vuelos&#10;            if (hayVuelos == 0) {&#10;                return 0;&#10;            }&#10;&#10;            return hayVuelos;&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Muestra los viajes sin ganancias (vista para cliente).&#10;     *&#10;     * Retorna:&#10;     * - 1 si hay viajes.&#10;     * - 0 si no hay viajes o si ocurre error.&#10;     */&#10;    public int obtenerDatosViajeCliente(Connection conn) {&#10;        String sql = &quot;SELECT idViaje, origen, destino, cantidadTotal, asientosClasePremium, asientosClaseEconomica, precioEconomica, precioPremium FROM viajes&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            int hayVuelos = 0;&#10;&#10;            while (rs.next()) {&#10;                hayVuelos = 1;&#10;&#10;                // Creamos el objeto Viajes sin ganancias (constructor diferente)&#10;                Viajes vjs1 = new Viajes(&#10;                        rs.getInt(&quot;idViaje&quot;),&#10;                        rs.getString(&quot;origen&quot;),&#10;                        rs.getString(&quot;destino&quot;),&#10;                        rs.getInt(&quot;cantidadTotal&quot;),&#10;                        rs.getInt(&quot;asientosClaseEconomica&quot;),&#10;                        rs.getInt(&quot;asientosClasePremium&quot;),&#10;                        rs.getDouble(&quot;precioEconomica&quot;),&#10;                        rs.getDouble(&quot;precioPremium&quot;)&#10;                );&#10;&#10;                // toString2 imprime un formato más &quot;cliente&quot; (sin ganancias)&#10;                System.out.println(vjs1.toString2());&#10;            }&#10;&#10;            // Si no hay vuelos, devolvemos 0&#10;            if (hayVuelos == 0) {&#10;                return 0;&#10;            }&#10;&#10;            return hayVuelos;&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Elimina un viaje por su ID.&#10;     *&#10;     * Qué hace:&#10;     * - Borra el viaje si existe.&#10;     * - Reordena IDs restando 1 a los que estén por encima del ID eliminado.&#10;     * - Reinicia AUTO_INCREMENT para mantener IDs &quot;consecutivos&quot;.&#10;     *&#10;     * Nota:&#10;     * - En sistemas reales no suele reordenarse IDs (puede afectar relaciones),&#10;     *   pero para un proyecto académico puede ser aceptable.&#10;     */&#10;    public void eliminaDatosViaje(int id, Connection conn) {&#10;        try (PreparedStatement psDelete = conn.prepareStatement(&quot;DELETE FROM viajes WHERE idViaje = ?&quot;)) {&#10;&#10;            psDelete.setInt(1, id);&#10;            int resultado = psDelete.executeUpdate();&#10;&#10;            if (resultado &gt; 0) {&#10;&#10;                // Reordenar IDs: si borraste el 3, el 4 pasa a 3, el 5 a 4, etc.&#10;                try (PreparedStatement psUpdate = conn.prepareStatement(&#10;                        &quot;UPDATE viajes SET idViaje = idViaje - 1 WHERE idViaje &gt; ?&quot;)) {&#10;&#10;                    psUpdate.setInt(1, id);&#10;                    psUpdate.executeUpdate();&#10;                }&#10;&#10;                // Reinicia el contador para que el próximo insert no se vaya a un número muy alto&#10;                try (Statement stmt = conn.createStatement()) {&#10;                    stmt.executeUpdate(&quot;ALTER TABLE viajes AUTO_INCREMENT = 1&quot;);&#10;                }&#10;&#10;                System.out.println(&quot;El viaje se ha eliminado y los índices han sido reordenados.&quot;);&#10;&#10;            } else {&#10;                System.out.println(&quot;El viaje no se ha eliminado (no existe ese ID).&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //     RESERVA / VENTAS&#10;    // =========================&#10;&#10;    /**&#10;     * Reserva asientos y registra la venta usando una transacción.&#10;     *&#10;     * Por qué transacción:&#10;     * - Para que &quot;actualizar el viaje&quot; y &quot;insertar la venta&quot; se guarden juntos.&#10;     * - Si algo falla, se hace rollback y no queda el sistema a medias.&#10;     *&#10;     * Pasos:&#10;     * 1) Bloquea el viaje con FOR UPDATE.&#10;     * 2) Revisa si hay asientos suficientes por clase.&#10;     * 3) Actualiza cupos y ganancias del viaje.&#10;     * 4) Inserta una fila en ventas.&#10;     */&#10;    public void insertarDatosVenta(int idViaje, int cantidadEconomica, int cantidadPremium, Cliente cliente, Connection conn) {&#10;&#10;        // FOR UPDATE bloquea la fila para evitar que dos compras vendan el mismo asiento al mismo tiempo&#10;        String sqlCheck = &quot;SELECT asientosClaseEconomica, asientosClasePremium, precioEconomica, precioPremium FROM viajes WHERE idViaje = ? FOR UPDATE&quot;;&#10;&#10;        // Actualiza: cantidadTotal, asientos por clase, vendidos y ganancias en una sola instrucción&#10;        String sqlUpdate = &quot;UPDATE viajes SET cantidadTotal = cantidadTotal - ?, asientosClaseEconomica = asientosClaseEconomica - ?, asientosClasePremium = asientosClasePremium - ?, asientosVendidos = asientosVendidos + ?, ganancias = ganancias + ? WHERE idViaje = ?&quot;;&#10;&#10;        try {&#10;            // Inicia modo transacción manual (ya no se guardan cambios automáticamente)&#10;            conn.setAutoCommit(false);&#10;&#10;            // 1) Verificar disponibilidad del viaje seleccionado&#10;            try (PreparedStatement psCheck = conn.prepareStatement(sqlCheck)) {&#10;                psCheck.setInt(1, idViaje);&#10;&#10;                try (ResultSet rs = psCheck.executeQuery()) {&#10;&#10;                    // Si no existe el viaje, cancelamos&#10;                    if (!rs.next()) {&#10;                        System.out.println(&quot;No existe el viaje con id &quot; + idViaje);&#10;                        conn.rollback();&#10;                        conn.setAutoCommit(true);&#10;                        return;&#10;                    }&#10;&#10;                    // Cupos actuales disponibles&#10;                    int disponiblesEco = rs.getInt(&quot;asientosClaseEconomica&quot;);&#10;                    int disponiblesPrem = rs.getInt(&quot;asientosClasePremium&quot;);&#10;&#10;                    // Precios unitarios actuales&#10;                    double precioEco = rs.getDouble(&quot;precioEconomica&quot;);&#10;                    double precioPrem = rs.getDouble(&quot;precioPremium&quot;);&#10;&#10;                    // 2) Validar que haya suficientes asientos en económica&#10;                    if (disponiblesEco &lt; cantidadEconomica) {&#10;                        System.out.println(&quot;No hay suficientes asientos económicos. Disponibles: &quot; + disponiblesEco);&#10;                        conn.rollback();&#10;                        conn.setAutoCommit(true);&#10;                        return;&#10;                    }&#10;&#10;                    // 3) Validar que haya suficientes asientos en premium&#10;                    if (disponiblesPrem &lt; cantidadPremium) {&#10;                        System.out.println(&quot;No hay suficientes asientos premium. Disponibles: &quot; + disponiblesPrem);&#10;                        conn.rollback();&#10;                        conn.setAutoCommit(true);&#10;                        return;&#10;                    }&#10;&#10;                    // 4) Calcular total a pagar&#10;                    double totalVenta = (precioEco * cantidadEconomica) + (precioPrem * cantidadPremium);&#10;&#10;                    // 5) Actualizar el viaje: restar asientos + sumar vendidos + sumar ganancias&#10;                    try (PreparedStatement psUpdate = conn.prepareStatement(sqlUpdate)) {&#10;&#10;                        int totalAsientos = cantidadEconomica + cantidadPremium;&#10;&#10;                        psUpdate.setInt(1, totalAsientos);       // resta a cantidadTotal&#10;                        psUpdate.setInt(2, cantidadEconomica);   // resta a eco&#10;                        psUpdate.setInt(3, cantidadPremium);     // resta a premium&#10;                        psUpdate.setInt(4, totalAsientos);       // suma a asientosvendidos&#10;                        psUpdate.setDouble(5, totalVenta);       // suma a ganancias&#10;                        psUpdate.setInt(6, idViaje);             // viaje a actualizar&#10;&#10;                        int updated = psUpdate.executeUpdate();&#10;&#10;                        // Si no se actualiza ninguna fila, algo salió mal (id no válido o error)&#10;                        if (updated &lt;= 0) {&#10;                            System.out.println(&quot;No se pudo actualizar los asientos del viaje.&quot;);&#10;                            conn.rollback();&#10;                            conn.setAutoCommit(true);&#10;                            return;&#10;                        }&#10;                    }&#10;&#10;                    // 6) Registrar venta en la tabla ventas&#10;                    int idCliente = (cliente != null) ? cliente.getIdCliente() : 0;&#10;&#10;                    Ventas venta = new Ventas(&#10;                            idCliente,&#10;                            idViaje,&#10;                            cantidadEconomica + cantidadPremium,&#10;                            cantidadEconomica,&#10;                            cantidadPremium,&#10;                            totalVenta&#10;                    );&#10;&#10;                    insertarVenta(venta, conn);&#10;&#10;                    // 7) Confirmar la transacción: se guardan los dos cambios (viaje + venta)&#10;                    conn.commit();&#10;                    conn.setAutoCommit(true);&#10;                }&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            // Si hay error, se debería revertir y volver a autocommit para no dejar la conexión “bloqueada”&#10;            try { conn.rollback(); } catch (Exception ignore) {}&#10;            try { conn.setAutoCommit(true); } catch (Exception ignore) {}&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //       PRECIOS&#10;    // =========================&#10;&#10;    /**&#10;     * Devuelve el precio unitario según el tipo de asiento.&#10;     * - tipoAsiento: 1 = económica, 2 = premium.&#10;     *&#10;     * Retorna:&#10;     * - Precio si existe el viaje.&#10;     * - -1 si no encuentra el viaje o ocurre error.&#10;     */&#10;    public double obtenerPrecioPorClase(int idViaje, int tipoAsiento, Connection conn) {&#10;        String sql = &quot;SELECT precioEconomica, precioPremium FROM viajes WHERE idViaje = ?&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setInt(1, idViaje);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    // Si tipoAsiento == 1 =&gt; económica, caso contrario =&gt; premium&#10;                    return (tipoAsiento == 1)&#10;                            ? rs.getDouble(&quot;precioEconomica&quot;)&#10;                            : rs.getDouble(&quot;precioPremium&quot;);&#10;                }&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return -1;&#10;    }&#10;&#10;    // =========================&#10;    //          VENTAS&#10;    // =========================&#10;&#10;    /**&#10;     * Inserta una venta en la tabla `ventas`.&#10;     *&#10;     * Detalles:&#10;     * - Busca el nombre/apellido/identificación del cliente para guardarlo en la venta.&#10;     * - Forma la cadena `cEco/cPrem` como &quot;eco / prem&quot; (ej: &quot;2 / 1&quot;).&#10;     * - Registra la fecha/hora exacta (Timestamp) del momento de compra.&#10;     */&#10;    public void insertarVenta(Ventas venta, Connection conn) {&#10;&#10;        // Consulta para traer información extra del cliente (se guarda en ventas como “histórico”)&#10;        String sqlBuscarCliente = &quot;SELECT nombre, apellido, identificacion FROM cliente WHERE idCliente = ?&quot;;&#10;&#10;        // Insert: usamos la columna idViaje en la tabla ventas para indicar el viaje asociado&#10;        String sqlInsertarVenta = &quot;INSERT INTO ventas (idCliente, idViaje, nombre, apellido, identificacion, cantidadAsientos, `cEco/cPrem`, total, fecha) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;;&#10;&#10;        try {&#10;            // 1) Variables que llenaremos con datos del cliente (si existe)&#10;            String nombre = &quot;&quot;;&#10;            String apellido = &quot;&quot;;&#10;            String identificacion = &quot;&quot;;&#10;&#10;            // 2) Buscar datos del cliente en tabla cliente&#10;            try (PreparedStatement psCli = conn.prepareStatement(sqlBuscarCliente)) {&#10;                psCli.setInt(1, venta.getIdCliente());&#10;&#10;                try (ResultSet rs = psCli.executeQuery()) {&#10;                    if (rs.next()) {&#10;                        nombre = rs.getString(&quot;nombre&quot;);&#10;                        apellido = rs.getString(&quot;apellido&quot;);&#10;                        identificacion = rs.getString(&quot;identificacion&quot;);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 3) Preparar el formato &quot;Eco / Prem&quot; (ej: &quot;3 / 0&quot;)&#10;            String textoAsientos = venta.getAsientosClaseEconomica() + &quot; / &quot; + venta.getAsientosClasePremium();&#10;&#10;            // 4) Tomar fecha/hora actual exacta&#10;            Timestamp ahora = Timestamp.from(java.time.Instant.now());&#10;&#10;            // 5) Insertar el registro de venta en BD&#10;            try (PreparedStatement ps = conn.prepareStatement(sqlInsertarVenta)) {&#10;&#10;                ps.setInt(1, venta.getIdCliente());&#10;                ps.setInt(2, venta.getIdViaje());&#10;                ps.setString(3, nombre);&#10;                ps.setString(4, apellido);&#10;                ps.setString(5, identificacion);&#10;                ps.setInt(6, venta.getCantidadAsientos());&#10;                ps.setString(7, textoAsientos);&#10;                ps.setDouble(8, venta.getTotalVenta());&#10;                ps.setTimestamp(9, ahora);&#10;&#10;                int resultado = ps.executeUpdate();&#10;&#10;                if (resultado &gt; 0) System.out.println(&quot;La venta se ha registrado correctamente..&quot;);&#10;                else System.out.println(&quot;La venta no se inserto..&quot;);&#10;&#10;            } catch (Exception ex) {&#10;                ex.printStackTrace();&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            System.out.println(&quot;Error al insertar venta: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Muestra las ventas registradas en la tabla `ventas`.&#10;     *&#10;     * Detalles:&#10;     * - Lee la columna `cEco/cPrem` (ej: &quot;2 / 1&quot;) y la convierte a enteros.&#10;     * - idViaje en BD se mapea como idViaje en el objeto Ventas.&#10;     */&#10;    public void obtenerVentas(Connection conn) {&#10;        String sql = &quot;SELECT idVenta, idCliente, idViaje, cantidadAsientos, `cEco/cPrem`, total, fecha FROM ventas&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            while (rs.next()) {&#10;                int idVenta = rs.getInt(&quot;idVenta&quot;);&#10;                int idCliente = rs.getInt(&quot;idCliente&quot;);&#10;                int idViaje = rs.getInt(&quot;idViaje&quot;);&#10;                int cantidad = rs.getInt(&quot;cantidadAsientos&quot;);&#10;                String asientosStr = rs.getString(&quot;cEco/cPrem&quot;);&#10;                double total = rs.getDouble(&quot;total&quot;);&#10;                Timestamp fecha = rs.getTimestamp(&quot;fecha&quot;);&#10;&#10;                // Convertir &quot;eco / prem&quot; a dos números (ej: &quot;2 / 1&quot; =&gt; eco=2, prem=1)&#10;                int eco = 0;&#10;                int prem = 0;&#10;&#10;                if (asientosStr != null &amp;&amp; asientosStr.contains(&quot;/&quot;)) {&#10;                    try {&#10;                        String[] partes = asientosStr.split(&quot;/&quot;);&#10;                        if (partes.length &gt;= 2) {&#10;                            eco = Integer.parseInt(partes[0].trim());&#10;                            prem = Integer.parseInt(partes[1].trim());&#10;                        }&#10;                    } catch (NumberFormatException e) {&#10;                        // Si falla el parseo, no rompemos el programa (se quedan en 0)&#10;                    }&#10;                }&#10;&#10;                // Crear el objeto venta con todo y mostrarlo&#10;                Ventas v = new Ventas(idVenta, idCliente, idViaje, cantidad, eco, prem, total, fecha);&#10;                System.out.println(v);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            System.out.println(&quot;Error al obtener ventas: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //   DISPONIBILIDAD ASIENTOS&#10;    // =========================&#10;&#10;    /**&#10;     * Devuelve cuántos asientos económicos quedan disponibles en un viaje.&#10;     * - Si no encuentra el viaje o hay error, retorna 0.&#10;     */&#10;    public int asientosDisponiblesClaseEconomica(int idViaje, Connection conn) {&#10;        String sql = &quot;SELECT asientosClaseEconomica FROM viajes WHERE idViaje = ?&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setInt(1, idViaje);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) return rs.getInt(&quot;asientosClaseEconomica&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Devuelve cuántos asientos premium quedan disponibles en un viaje.&#10;     * - Si no encuentra el viaje o hay error, retorna 0.&#10;     */&#10;    public int asientosDisponiblesClasePremium(int idViaje, Connection conn) {&#10;        String sql = &quot;SELECT asientosClasePremium FROM viajes WHERE idViaje = ?&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setInt(1, idViaje);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) return rs.getInt(&quot;asientosClasePremium&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package clases;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.Statement;&#10;import java.sql.Timestamp;&#10;&#10;/**&#10; * Clase Utilidades: concentra funciones &quot;de apoyo&quot; para trabajar con la BD.&#10; *&#10; * Explicación simple (pero clara):&#10; * - Abre la conexión a MySQL.&#10; * - Inserta y consulta datos de: clientes, viajes y ventas.&#10; * - Permite reiniciar tablas (borrar todo y reiniciar IDs).&#10; * - Controla disponibilidad de asientos por clase.&#10; * - Realiza la reserva con transacción para no dejar datos incompletos.&#10; */&#10;public class Utilidades {&#10;&#10;    /**&#10;     * Crea y devuelve una conexión a MySQL usando datos fijos (hardcodeados).&#10;     * - Si la conexión falla (credenciales, BD apagada, etc.) imprime error y retorna null.&#10;     */&#10;    public Connection getConnection() {&#10;        String url = &quot;jdbc:mysql://localhost:3306/cliente&quot;;&#10;        String user = &quot;root&quot;;&#10;        String passwd = &quot;sasa&quot;;&#10;&#10;        try {&#10;            // DriverManager se encarga de abrir la conexión con la URL + credenciales&#10;            return DriverManager.getConnection(url, user, passwd);&#10;        } catch (Exception ex) {&#10;            // Para depurar rápido: muestra el motivo del fallo en consola&#10;            ex.printStackTrace();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // =========================&#10;    //         CLIENTES&#10;    // =========================&#10;&#10;    /**&#10;     * Inserta un cliente en la tabla `cliente`.&#10;     *&#10;     * Qué hace paso a paso:&#10;     * - Guarda nombre, apellido, correo e identificación.&#10;     * - Calcula el total de asientos comprados si no viene definido.&#10;     * - Guarda cuántos asientos fueron económicos y cuántos premium.&#10;     * - Si la inserción fue exitosa, busca el idCliente generado y lo asigna al objeto Cliente.&#10;     *&#10;     * Nota:&#10;     * - No lanza excepciones hacia afuera, solo imprime la traza.&#10;     */&#10;    public void insetarDatos(Cliente cliente, Connection conn) {&#10;        String sql = &quot;INSERT INTO cliente (nombre, apellido, email, identificacion, asientosComprados, asientosClaseEconomica, asientosClasePremium, precio) VALUES (?,?,?,?,?,?,?,?)&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            // 1) Guardamos los datos básicos del cliente en el INSERT&#10;            ps.setString(1, cliente.getNombre());&#10;            ps.setString(2, cliente.getApellido());&#10;            ps.setString(3, cliente.getEmail());&#10;            ps.setString(4, cliente.getIdentificacion());&#10;&#10;            // 2) Total de asientos: si está en 0, lo calculamos sumando eco + premium&#10;            int totalAsientos = cliente.getAsientosComprados();&#10;            if (totalAsientos &lt;= 0) {&#10;                totalAsientos = cliente.getAsientosClaseEconomica() + cliente.getAsientosClasePremium();&#10;            }&#10;&#10;            // 3) Guardamos los asientos y el precio en la tabla&#10;            ps.setInt(5, totalAsientos);&#10;            ps.setInt(6, cliente.getAsientosClaseEconomica());&#10;            ps.setInt(7, cliente.getAsientosClasePremium());&#10;            ps.setDouble(8, cliente.getPrecio());&#10;&#10;            // 4) Ejecuta el INSERT y devuelve cuántas filas se insertaron&#10;            int resultado = ps.executeUpdate();&#10;&#10;            if (resultado &gt; 0) {&#10;                System.out.println(&quot;Venta Registrada&quot;);&#10;&#10;                // 5) Recuperar el ID para que las ventas queden asociadas al cliente correcto&#10;                //    (se busca por identificacion y se toma el último id insertado con esa identificacion)&#10;                try (PreparedStatement psId = conn.prepareStatement(&#10;                        &quot;SELECT idCliente FROM cliente WHERE identificacion = ? ORDER BY idCliente DESC LIMIT 1&quot;)) {&#10;&#10;                    psId.setString(1, cliente.getIdentificacion());&#10;&#10;                    try (ResultSet rs = psId.executeQuery()) {&#10;                        if (rs.next()) {&#10;                            // Guardamos el id generado dentro del objeto cliente en memoria&#10;                            cliente.setIdCliente(rs.getInt(&quot;idCliente&quot;));&#10;                        }&#10;                    }&#10;&#10;                } catch (Exception exId) {&#10;                    // Si falla solo esta parte, el cliente pudo insertarse igual&#10;                    exId.printStackTrace();&#10;                }&#10;&#10;            } else {&#10;                System.out.println(&quot;El Cliente no se insertó.&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resetea la tabla `cliente`:&#10;     * - Desactiva temporalmente FOREIGN_KEY_CHECKS para evitar error por llaves foráneas.&#10;     * - TRUNCATE borra todo y reinicia el AUTO_INCREMENT (IDs desde 1).&#10;     * - Luego vuelve a activar FOREIGN_KEY_CHECKS.&#10;     */&#10;    public void resetearClientes(Connection conn) {&#10;        try (Statement stmt = conn.createStatement()) {&#10;&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 0&quot;);&#10;            stmt.executeUpdate(&quot;TRUNCATE TABLE cliente&quot;);&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 1&quot;);&#10;&#10;            System.out.println(&quot;Tabla de clientes reseteada (ID reiniciado).&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resetea la tabla `viajes`:&#10;     * - Borra todos los viajes y reinicia el contador de IDs.&#10;     */&#10;    public void resetearviajes(Connection conn) {&#10;        try (Statement stmt = conn.createStatement()) {&#10;&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 0&quot;);&#10;            stmt.executeUpdate(&quot;TRUNCATE TABLE viajes&quot;);&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 1&quot;);&#10;&#10;            System.out.println(&quot;Tabla de viajes reseteada (ID reiniciado).&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resetea la tabla `ventas`:&#10;     * - Borra todas las ventas y reinicia el contador de IDs.&#10;     */&#10;    public void resetearventas(Connection conn) {&#10;        try (Statement stmt = conn.createStatement()) {&#10;&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 0&quot;);&#10;            stmt.executeUpdate(&quot;TRUNCATE TABLE ventas&quot;);&#10;            stmt.executeUpdate(&quot;SET FOREIGN_KEY_CHECKS = 1&quot;);&#10;&#10;            System.out.println(&quot;Tabla de clientes ventas (ID reiniciado).&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //      LISTAR CLIENTES&#10;    // =========================&#10;&#10;    /**&#10;     * Muestra por consola los clientes registrados.&#10;     * - Consulta campos básicos y los imprime creando un objeto Cliente por cada fila.&#10;     */&#10;    public void obtenerDatos(Connection conn) {&#10;        String sql = &quot;SELECT idCliente, nombre, apellido, email, identificacion, asientosComprados, asientosClaseEconomica, asientosClasePremium, precio FROM cliente&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            while (rs.next()) {&#10;                // Creamos el objeto Cliente con los datos de la fila actual&#10;                Cliente cli = new Cliente(&#10;                        rs.getInt(&quot;idCliente&quot;),&#10;                        rs.getString(&quot;nombre&quot;),&#10;                        rs.getString(&quot;apellido&quot;),&#10;                        rs.getString(&quot;email&quot;),&#10;                        rs.getString(&quot;identificacion&quot;),&#10;                        rs.getInt(&quot;asientosComprados&quot;),&#10;                        rs.getInt(&quot;asientosClaseEconomica&quot;),&#10;                        rs.getInt(&quot;asientosClasePremium&quot;),&#10;                        rs.getDouble(&quot;precio&quot;));&#10;                System.out.println(cli+&quot;\n&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //          VIAJES&#10;    // =========================&#10;&#10;    /**&#10;     * Inserta un viaje en la tabla `viajes`.&#10;     *&#10;     * Detalles:&#10;     * - Guarda origen/destino, cupos totales, cupos por clase y precios.&#10;     * - Inicializa asientosvendidos en 0 porque el viaje inicia sin ventas.&#10;     * - Guarda ganancias iniciales (normalmente 0).&#10;     */&#10;    public void insetarDatosViaje(Viajes viaje, Connection conn) {&#10;        String sql = &quot;INSERT INTO viajes (origen, destino, cantidadTotal, asientosClasePremium, asientosClaseEconomica, precioEconomica, precioPremium, asientosVendidos,ganancias) VALUES (?,?,?,?,?,?,?,?,?)&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            ps.setString(1, viaje.getOrigen());&#10;            ps.setString(2, viaje.getDestino());&#10;            ps.setInt(3, viaje.getCantidadTotal());&#10;&#10;            // Cupos por clase&#10;            ps.setInt(4, viaje.getAsientosClasePremium());&#10;            ps.setInt(5, viaje.getAsientosClaseEconomica());&#10;&#10;            // Precios por clase&#10;            ps.setDouble(6, viaje.getPrecioEconomica());&#10;            ps.setDouble(7, viaje.getPrecioPremium());&#10;&#10;            // Viaje recién creado =&gt; 0 vendidos&#10;            ps.setInt(8, 0);&#10;&#10;            // Ganancias iniciales (normalmente 0)&#10;            ps.setDouble(9, viaje.getGanancias());&#10;&#10;            int resultado = ps.executeUpdate();&#10;&#10;            if (resultado &gt; 0) System.out.println(&quot;El viaje se ha insertado correctamente..&quot;);&#10;            else System.out.println(&quot;El viaje no se inserto..&quot;);&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Muestra todos los viajes con ganancias (vista para administrador).&#10;     *&#10;     * Retorna:&#10;     * - 1 si hay viajes.&#10;     * - 0 si no hay viajes o si ocurre error.&#10;     */&#10;    public int obtenerDatosViaje(Connection conn) {&#10;        String sql = &quot;SELECT idViaje, origen, destino, cantidadTotal, asientosClasePremium, asientosClaseEconomica, precioEconomica, precioPremium, asientosVendidos, ganancias FROM viajes&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            int hayVuelos = 0;&#10;&#10;            while (rs.next()) {&#10;                hayVuelos = 1;&#10;&#10;                // Creamos el objeto Viajes con toda la info&#10;                Viajes vjs = new Viajes(&#10;                rs.getInt(&quot;idViaje&quot;),&#10;                rs.getString(&quot;origen&quot;),&#10;                rs.getString(&quot;destino&quot;),&#10;                rs.getInt(&quot;cantidadTotal&quot;),&#10;                rs.getInt(&quot;asientosClasePremium&quot;),&#10;                rs.getInt(&quot;asientosClaseEconomica&quot;),&#10;                rs.getDouble(&quot;precioEconomica&quot;),&#10;                rs.getDouble(&quot;precioPremium&quot;),&#10;                rs.getInt(&quot;asientosVendidos&quot;),&#10;                rs.getDouble(&quot;ganancias&quot;)&#10;                );&#10;&#10;                System.out.println(vjs);&#10;            }&#10;&#10;            // Si no entró al while, no hay vuelos&#10;            if (hayVuelos == 0) {&#10;                return 0;&#10;            }&#10;&#10;            return hayVuelos;&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Muestra los viajes sin ganancias (vista para cliente).&#10;     *&#10;     * Retorna:&#10;     * - 1 si hay viajes.&#10;     * - 0 si no hay viajes o si ocurre error.&#10;     */&#10;    public int obtenerDatosViajeCliente(Connection conn) {&#10;        String sql = &quot;SELECT idViaje, origen, destino, cantidadTotal, asientosClasePremium, asientosClaseEconomica, precioEconomica, precioPremium FROM viajes&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            int hayVuelos = 0;&#10;&#10;            while (rs.next()) {&#10;                hayVuelos = 1;&#10;&#10;                // Creamos el objeto Viajes sin ganancias (constructor diferente)&#10;                Viajes vjs1 = new Viajes(&#10;                        rs.getInt(&quot;idViaje&quot;),&#10;                        rs.getString(&quot;origen&quot;),&#10;                        rs.getString(&quot;destino&quot;),&#10;                        rs.getInt(&quot;cantidadTotal&quot;),&#10;                        rs.getInt(&quot;asientosClaseEconomica&quot;),&#10;                        rs.getInt(&quot;asientosClasePremium&quot;),&#10;                        rs.getDouble(&quot;precioEconomica&quot;),&#10;                        rs.getDouble(&quot;precioPremium&quot;)&#10;                );&#10;&#10;                // toString2 imprime un formato más &quot;cliente&quot; (sin ganancias)&#10;                System.out.println(vjs1.toString2());&#10;            }&#10;&#10;            // Si no hay vuelos, devolvemos 0&#10;            if (hayVuelos == 0) {&#10;                return 0;&#10;            }&#10;&#10;            return hayVuelos;&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Elimina un viaje por su ID.&#10;     *&#10;     * Qué hace:&#10;     * - Borra el viaje si existe.&#10;     * - Reordena IDs restando 1 a los que estén por encima del ID eliminado.&#10;     * - Reinicia AUTO_INCREMENT para mantener IDs &quot;consecutivos&quot;.&#10;     *&#10;     * Nota:&#10;     * - En sistemas reales no suele reordenarse IDs (puede afectar relaciones),&#10;     *   pero para un proyecto académico puede ser aceptable.&#10;     */&#10;    public void eliminaDatosViaje(int id, Connection conn) {&#10;        try (PreparedStatement psDelete = conn.prepareStatement(&quot;DELETE FROM viajes WHERE idViaje = ?&quot;)) {&#10;&#10;            psDelete.setInt(1, id);&#10;            int resultado = psDelete.executeUpdate();&#10;&#10;            if (resultado &gt; 0) {&#10;&#10;                // Reordenar IDs: si borraste el 3, el 4 pasa a 3, el 5 a 4, etc.&#10;                try (PreparedStatement psUpdate = conn.prepareStatement(&#10;                        &quot;UPDATE viajes SET idViaje = idViaje - 1 WHERE idViaje &gt; ?&quot;)) {&#10;&#10;                    psUpdate.setInt(1, id);&#10;                    psUpdate.executeUpdate();&#10;                }&#10;&#10;                // Reinicia el contador para que el próximo insert no se vaya a un número muy alto&#10;                try (Statement stmt = conn.createStatement()) {&#10;                    stmt.executeUpdate(&quot;ALTER TABLE viajes AUTO_INCREMENT = 1&quot;);&#10;                }&#10;&#10;                System.out.println(&quot;El viaje se ha eliminado y los índices han sido reordenados.&quot;);&#10;&#10;            } else {&#10;                System.out.println(&quot;El viaje no se ha eliminado (no existe ese ID).&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //     RESERVA / VENTAS&#10;    // =========================&#10;&#10;    /**&#10;     * Reserva asientos y registra la venta usando una transacción.&#10;     *&#10;     * Por qué transacción:&#10;     * - Para que &quot;actualizar el viaje&quot; y &quot;insertar la venta&quot; se guarden juntos.&#10;     * - Si algo falla, se hace rollback y no queda el sistema a medias.&#10;     *&#10;     * Pasos:&#10;     * 1) Bloquea el viaje con FOR UPDATE.&#10;     * 2) Revisa si hay asientos suficientes por clase.&#10;     * 3) Actualiza cupos y ganancias del viaje.&#10;     * 4) Inserta una fila en ventas.&#10;     */&#10;    public void insertarDatosVenta(int idViaje, int cantidadEconomica, int cantidadPremium, Cliente cliente, Connection conn) {&#10;&#10;        // FOR UPDATE bloquea la fila para evitar que dos compras vendan el mismo asiento al mismo tiempo&#10;        String sqlCheck = &quot;SELECT asientosClaseEconomica, asientosClasePremium, precioEconomica, precioPremium FROM viajes WHERE idViaje = ? FOR UPDATE&quot;;&#10;&#10;        // Actualiza: cantidadTotal, asientos por clase, vendidos y ganancias en una sola instrucción&#10;        String sqlUpdate = &quot;UPDATE viajes SET cantidadTotal = cantidadTotal - ?, asientosClaseEconomica = asientosClaseEconomica - ?, asientosClasePremium = asientosClasePremium - ?, asientosVendidos = asientosVendidos + ?, ganancias = ganancias + ? WHERE idViaje = ?&quot;;&#10;&#10;        try {&#10;            // Inicia modo transacción manual (ya no se guardan cambios automáticamente)&#10;            conn.setAutoCommit(false);&#10;&#10;            // 1) Verificar disponibilidad del viaje seleccionado&#10;            try (PreparedStatement psCheck = conn.prepareStatement(sqlCheck)) {&#10;                psCheck.setInt(1, idViaje);&#10;&#10;                try (ResultSet rs = psCheck.executeQuery()) {&#10;&#10;                    // Si no existe el viaje, cancelamos&#10;                    if (!rs.next()) {&#10;                        System.out.println(&quot;No existe el viaje con id &quot; + idViaje);&#10;                        conn.rollback();&#10;                        conn.setAutoCommit(true);&#10;                        return;&#10;                    }&#10;&#10;                    // Cupos actuales disponibles&#10;                    int disponiblesEco = rs.getInt(&quot;asientosClaseEconomica&quot;);&#10;                    int disponiblesPrem = rs.getInt(&quot;asientosClasePremium&quot;);&#10;&#10;                    // Precios unitarios actuales&#10;                    double precioEco = rs.getDouble(&quot;precioEconomica&quot;);&#10;                    double precioPrem = rs.getDouble(&quot;precioPremium&quot;);&#10;&#10;                    // 2) Validar que haya suficientes asientos en económica&#10;                    if (disponiblesEco &lt; cantidadEconomica) {&#10;                        System.out.println(&quot;No hay suficientes asientos económicos. Disponibles: &quot; + disponiblesEco);&#10;                        conn.rollback();&#10;                        conn.setAutoCommit(true);&#10;                        return;&#10;                    }&#10;&#10;                    // 3) Validar que haya suficientes asientos en premium&#10;                    if (disponiblesPrem &lt; cantidadPremium) {&#10;                        System.out.println(&quot;No hay suficientes asientos premium. Disponibles: &quot; + disponiblesPrem);&#10;                        conn.rollback();&#10;                        conn.setAutoCommit(true);&#10;                        return;&#10;                    }&#10;&#10;                    // 4) Calcular total a pagar&#10;                    double totalVenta = (precioEco * cantidadEconomica) + (precioPrem * cantidadPremium);&#10;&#10;                    // 5) Actualizar el viaje: restar asientos + sumar vendidos + sumar ganancias&#10;                    try (PreparedStatement psUpdate = conn.prepareStatement(sqlUpdate)) {&#10;&#10;                        int totalAsientos = cantidadEconomica + cantidadPremium;&#10;&#10;                        psUpdate.setInt(1, totalAsientos);       // resta a cantidadTotal&#10;                        psUpdate.setInt(2, cantidadEconomica);   // resta a eco&#10;                        psUpdate.setInt(3, cantidadPremium);     // resta a premium&#10;                        psUpdate.setInt(4, totalAsientos);       // suma a asientosvendidos&#10;                        psUpdate.setDouble(5, totalVenta);       // suma a ganancias&#10;                        psUpdate.setInt(6, idViaje);             // viaje a actualizar&#10;&#10;                        int updated = psUpdate.executeUpdate();&#10;&#10;                        // Si no se actualiza ninguna fila, algo salió mal (id no válido o error)&#10;                        if (updated &lt;= 0) {&#10;                            System.out.println(&quot;No se pudo actualizar los asientos del viaje.&quot;);&#10;                            conn.rollback();&#10;                            conn.setAutoCommit(true);&#10;                            return;&#10;                        }&#10;                    }&#10;&#10;                    // 6) Registrar venta en la tabla ventas&#10;                    int idCliente = (cliente != null) ? cliente.getIdCliente() : 0;&#10;&#10;                    Ventas venta = new Ventas(&#10;                            idCliente,&#10;                            idViaje,&#10;                            cantidadEconomica + cantidadPremium,&#10;                            cantidadEconomica,&#10;                            cantidadPremium,&#10;                            totalVenta&#10;                    );&#10;&#10;                    insertarVenta(venta, conn);&#10;&#10;                    // 7) Confirmar la transacción: se guardan los dos cambios (viaje + venta)&#10;                    conn.commit();&#10;                    conn.setAutoCommit(true);&#10;                }&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            // Si hay error, se debería revertir y volver a autocommit para no dejar la conexión “bloqueada”&#10;            try { conn.rollback(); } catch (Exception ignore) {}&#10;            try { conn.setAutoCommit(true); } catch (Exception ignore) {}&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //       PRECIOS&#10;    // =========================&#10;&#10;    /**&#10;     * Devuelve el precio unitario según el tipo de asiento.&#10;     * - tipoAsiento: 1 = económica, 2 = premium.&#10;     *&#10;     * Retorna:&#10;     * - Precio si existe el viaje.&#10;     * - -1 si no encuentra el viaje o ocurre error.&#10;     */&#10;    public double obtenerPrecioPorClase(int idViaje, int tipoAsiento, Connection conn) {&#10;        String sql = &quot;SELECT precioEconomica, precioPremium FROM viajes WHERE idViaje = ?&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setInt(1, idViaje);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    // Si tipoAsiento == 1 =&gt; económica, caso contrario =&gt; premium&#10;                    return (tipoAsiento == 1)&#10;                            ? rs.getDouble(&quot;precioEconomica&quot;)&#10;                            : rs.getDouble(&quot;precioPremium&quot;);&#10;                }&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return -1;&#10;    }&#10;&#10;    // =========================&#10;    //          VENTAS&#10;    // =========================&#10;&#10;    /**&#10;     * Inserta una venta en la tabla `ventas`.&#10;     *&#10;     * Detalles:&#10;     * - Busca el nombre/apellido/identificación del cliente para guardarlo en la venta.&#10;     * - Forma la cadena `cEco/cPrem` como &quot;eco / prem&quot; (ej: &quot;2 / 1&quot;).&#10;     * - Registra la fecha/hora exacta (Timestamp) del momento de compra.&#10;     */&#10;    public void insertarVenta(Ventas venta, Connection conn) {&#10;&#10;        // Consulta para traer información extra del cliente (se guarda en ventas como “histórico”)&#10;        String sqlBuscarCliente = &quot;SELECT nombre, apellido, identificacion FROM cliente WHERE idCliente = ?&quot;;&#10;&#10;        // Insert: usamos la columna idViaje en la tabla ventas para indicar el viaje asociado&#10;        String sqlInsertarVenta = &quot;INSERT INTO ventas (idCliente, idViaje, nombre, apellido, identificacion, cantidadAsientos, `cEco/cPrem`, total, fecha) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;;&#10;&#10;        try {&#10;            // 1) Variables que llenaremos con datos del cliente (si existe)&#10;            String nombre = &quot;&quot;;&#10;            String apellido = &quot;&quot;;&#10;            String identificacion = &quot;&quot;;&#10;&#10;            // 2) Buscar datos del cliente en tabla cliente&#10;            try (PreparedStatement psCli = conn.prepareStatement(sqlBuscarCliente)) {&#10;                psCli.setInt(1, venta.getIdCliente());&#10;&#10;                try (ResultSet rs = psCli.executeQuery()) {&#10;                    if (rs.next()) {&#10;                        nombre = rs.getString(&quot;nombre&quot;);&#10;                        apellido = rs.getString(&quot;apellido&quot;);&#10;                        identificacion = rs.getString(&quot;identificacion&quot;);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 3) Preparar el formato &quot;Eco / Prem&quot; (ej: &quot;3 / 0&quot;)&#10;            String textoAsientos = venta.getAsientosClaseEconomica() + &quot; / &quot; + venta.getAsientosClasePremium();&#10;&#10;            // 4) Tomar fecha/hora actual exacta&#10;            Timestamp ahora = Timestamp.from(java.time.Instant.now());&#10;&#10;            // 5) Insertar el registro de venta en BD&#10;            try (PreparedStatement ps = conn.prepareStatement(sqlInsertarVenta)) {&#10;&#10;                ps.setInt(1, venta.getIdCliente());&#10;                ps.setInt(2, venta.getIdViaje());&#10;                ps.setString(3, nombre);&#10;                ps.setString(4, apellido);&#10;                ps.setString(5, identificacion);&#10;                ps.setInt(6, venta.getCantidadAsientos());&#10;                ps.setString(7, textoAsientos);&#10;                ps.setDouble(8, venta.getTotalVenta());&#10;                ps.setTimestamp(9, ahora);&#10;&#10;                int resultado = ps.executeUpdate();&#10;&#10;                if (resultado &gt; 0) System.out.println(&quot;La venta se ha registrado correctamente..&quot;);&#10;                else System.out.println(&quot;La venta no se inserto..&quot;);&#10;&#10;            } catch (Exception ex) {&#10;                ex.printStackTrace();&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            System.out.println(&quot;Error al insertar venta: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Muestra las ventas registradas en la tabla `ventas`.&#10;     *&#10;     * Detalles:&#10;     * - Lee la columna `cEco/cPrem` (ej: &quot;2 / 1&quot;) y la convierte a enteros.&#10;     * - idViaje en BD se mapea como idViaje en el objeto Ventas.&#10;     */&#10;    public void obtenerVentas(Connection conn) {&#10;        String sql = &quot;SELECT idVenta, idCliente, idViaje, cantidadAsientos, `cEco/cPrem`, total, fecha FROM ventas&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql);&#10;             ResultSet rs = ps.executeQuery()) {&#10;&#10;            while (rs.next()) {&#10;                int idVenta = rs.getInt(&quot;idVenta&quot;);&#10;                int idCliente = rs.getInt(&quot;idCliente&quot;);&#10;                int idViaje = rs.getInt(&quot;idViaje&quot;);&#10;                int cantidad = rs.getInt(&quot;cantidadAsientos&quot;);&#10;                String asientosStr = rs.getString(&quot;cEco/cPrem&quot;);&#10;                double total = rs.getDouble(&quot;total&quot;);&#10;                Timestamp fecha = rs.getTimestamp(&quot;fecha&quot;);&#10;&#10;                // Convertir &quot;eco / prem&quot; a dos números (ej: &quot;2 / 1&quot; =&gt; eco=2, prem=1)&#10;                int eco = 0;&#10;                int prem = 0;&#10;&#10;                if (asientosStr != null &amp;&amp; asientosStr.contains(&quot;/&quot;)) {&#10;                    try {&#10;                        String[] partes = asientosStr.split(&quot;/&quot;);&#10;                        if (partes.length &gt;= 2) {&#10;                            eco = Integer.parseInt(partes[0].trim());&#10;                            prem = Integer.parseInt(partes[1].trim());&#10;                        }&#10;                    } catch (NumberFormatException e) {&#10;                        // Si falla el parseo, no rompemos el programa (se quedan en 0)&#10;                    }&#10;                }&#10;&#10;                // Crear el objeto venta con todo y mostrarlo&#10;                Ventas v = new Ventas(idVenta, idCliente, idViaje, cantidad, eco, prem, total, fecha);&#10;                System.out.println(v);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            System.out.println(&quot;Error al obtener ventas: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;        }&#10;    }&#10;&#10;    // =========================&#10;    //   DISPONIBILIDAD ASIENTOS&#10;    // =========================&#10;&#10;    /**&#10;     * Devuelve cuántos asientos económicos quedan disponibles en un viaje.&#10;     * - Si no encuentra el viaje o hay error, retorna 0.&#10;     */&#10;    public int asientosDisponiblesClaseEconomica(int idViaje, Connection conn) {&#10;        String sql = &quot;SELECT asientosClaseEconomica FROM viajes WHERE idViaje = ?&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setInt(1, idViaje);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) return rs.getInt(&quot;asientosClaseEconomica&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;    /**&#10;     * Devuelve cuántos asientos premium quedan disponibles en un viaje.&#10;     * - Si no encuentra el viaje o hay error, retorna 0.&#10;     */&#10;    public int asientosDisponiblesClasePremium(int idViaje, Connection conn) {&#10;        String sql = &quot;SELECT asientosClasePremium FROM viajes WHERE idViaje = ?&quot;;&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setInt(1, idViaje);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) return rs.getInt(&quot;asientosClasePremium&quot;);&#10;            }&#10;&#10;        } catch (Exception ex) {&#10;            ex.printStackTrace();&#10;        }&#10;&#10;        return 0;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>